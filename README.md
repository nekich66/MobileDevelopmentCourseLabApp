# Инструкции к практикам и шаблон проекта

### 1. Практика "Статья"

1. Откройте репозиторий https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp
Этот шаблон станет общим для ваших приложений. 
2. Сделайте fork этого репозитория в свой аккаунт.
![img.png](readmeImg/img.png)
3. Склонируйте репозиторий со своей страницы в Android Studio. 
4. Проверьте, что проект собирается - приложение с тремя вкладками запускается. 
5. Переключитьесь на новую ветку, назовите ее по задаче, например `feature/article`
6. Работайте с файлами ArticleFragment.kt и fragment_article.xml
7. Сверстайте разметку вашей будущей статьи в fragment_article.xml.
Она должна включать: заголовок, подзаголовок, основную часть статьи, одно или несколько изображений, кнопки лайк-дизлайк.
Вам пригодятся: ScrollView, LinearLayout, TextView, ImageView, ImageButton. Остановимся в рамках этой задачи на них. 
8. Строки можно не выносить - мы их используем однажды и когда-то переделаем. 
9. Выставьте отступы с помощью margin и padding (https://metanit.com/java/android/3.10.php). Выставьте размеры фото и кнопок. 
Значения повторяются? Время вынести их в dimen: https://metanit.com/java/android/2.6.php
10. Стили текстов можно описывать для каждого TextView. А нужно создать стили в styles.xml и навсегда забыть о заполнении 
кучи полей: https://devcolibri.com/unit/%D1%83%D1%80%D0%BE%D0%BA-4-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%BC-styles-xml-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE-%D1%81-textappeara-2/
11. Работа с разметкой закончена. Приступаем к логике в ArticleFragment.kt. 
12. Загрузим картинку. Испортируйте библиотеку Glide (https://github.com/bumptech/glide) и загрузите изображение
по ссылке. Делается это в классе фрагмента. 
13. Оживите кнопки лайка-дизлайка: определите слушателя для кнопок (https://startandroid.ru/ru/uroki/vse-uroki-spiskom/16-urok-9-obrabotchiki-sobytij-na-primere-button.html)
и обновляйте значение счетчика.
14. Порадуйтесь результату и запечатлите его в скриншоте. Добавьте его в README.md.
15. Закоммитьте изменения и отправьте в гитхаб. Там создайте пулл-реквест (внимание - в свой мастер, а не шаблона),
а ссылку на него приложите в ведомость. Преподаватель прижет и проверит вашу работу, оставит комментарии. Как только 
препод напишет "Ок, заливай" - заливайте ваш пулл-реквест в мастер. 
16. Обновите и переключитесь на мастер. Вы готовы к следующей задаче

### 2. Практика "Список"

Эта практика позволит вам работать со списочными представлениями, что позволяет не только делать сами списки, но и гибко управлять содержимым экрана. 

1. Выберите тему, элементы которой можно представить в виде списка. Это может быть список сотрудников, книга рецептов, афиша мероприятий. В дальнейших практиках мы научимся редактировать и добавлять записи в этот список.
2. Встаньте в ветку master, там уже должна быть Практика 1, и начните новую ветку. 
3. Переименуйте все, что связано с SecondFragment, в соответствии с темой. Например ListFragment
4. Начнем с того, из чего будет будет состоять список. Создайте разметку одного элемента в папке layout
5. В разметке бывшего SecondFragment создайте единственный виджет - RecyclerView. Не забудьте установить LayoutManager
6. Создайте класс - модель ваших данных, например Рецепт, Сотрудник и т.д.
7. Создайте источник данных, возвращающий список моделей из п. 6.
8. Создайте адаптер (Adapter), который будет отображать ваши данные из п.7 на элементах из п.4. Для этого:
9. Создайте ViewHolder - класс, который запомнит все, что нужно для обращения к элементу разметки, который и дается ему на вход. Достаточно привязять itemView к binding, и предоставлять последний.
10. Создайте в адаптере коллекцию, в которой будут храниться элементы.
11. Переопределите метод onCreateViewHolder так, чтобы он принимал элемент разметки и возвращал созданный в п.9 ViewHolder.
12. Теперь, если мы переопределим метод onBindViewHolder, мы можем взять элемент из коллекции (10) и холдер (9), и заполнить вьюшку из холдера данными из элемента коллекции. Здесь же можно навесить обработчики событий.
13. Сделайте в адаптере метод, который принимает коллекцию и говорит адаптеру обновиться с этими новыми данными (notifyDatasetChanged). Так мы и поставим данные в RecyclerView.
14. Создайте во Fragment экземпляр адаптера. Назначьте его RecyclerView и воспользуйтесь методом установки данных (13) с данными из источника (7). Теперь, когда мы запустим приложение, на втором фрагменте появится список!
15. Попробуйте сделать список интерактивным. Например, при нажатии на элемент будут показаны скрытые подробности. Изменить один элемент поможет notifyItemChanged
16. Повторите пп. 14-16 из прошлой практики

### 3. Практика "Карточка"

В рамках этой практики вам предстоит подробнее познакомиться с навигацией и гибкими разметками при помощи ConstraintLayout, а также с некоторыми применениями Intent. 

1. Для выполнения этой практики вам будут необходимы результаты Практики 2 "Список". Выполните сначала ее. 
2. После вливания "Списка" встаньте в мастер и стартуйте новую ветку.
3. Подумайте, какую более полную информацию можно показывать по элементам вашего списка. Например, для списка рецептов это будет сам рецепт, для списка сотрудников - карточка сотрудника, для расписания занятий - информация о занятии. Именно переход на этот экран мы и будем делать.
4. Создайте пару фрагмент + разметка, которые будут отвечать за ваш экран.
5. В графе навигации (mobile_navigation.xml) создайте новый destination. Для фрагмента списка добавьте новый action, который позволяет сделать переход на этот новый экран.
6. Вместо раскрытия элемента сделайте новый обработчик нажатия клика на элемент списка. Теперь должен происходить переход по action из прошлого пункта. https://developer.android.com/guide/navigation/use-graph/navigate#id 
7. Чтобы передать в "Карточку" данные из элемента списка, при переходе добавьте данные в Bundle и приложите его (или с помощью аргументов навигации). Чтобы можно было передать модель данных целиком, сделайте ее Serializable. https://developer.android.com/guide/navigation/use-graph/pass-data#bundle
8. Чтобы достать данные в "Карточке", воспользуйтесь свойством фрагмента arguments. Теперь у вас есть данные, которыми вы заполните верстку. 
9. Сверстайте вашу "Карточку" в файле разметки. Используйте ConstraintLayout и его возможности: относительное позиционирование (startTo_start, topTo и тд), выравнивание и оступы, барьеры (barrier), цепочки (chain), смещения (bias) и т.д. То, что вам понадобится, зависит от вашей фантазии, но постарайтесь использовать большую часть из списка возможностей. 
10. Позаботьтесь о том, чтобы на вашем экране работала и системная кнопка "Назад", и стрелка в тулбаре. Кроме этого, на этом экране не нужен навбар с тремя основынми экранами. Это можно настроить в контейнере наших фрагментов - MainActivity.
11. Сделаем возможность поделиться информацией из "Карточки". Добавим на тулбар иконку "Поделиться". Делается это при помощи меню.
12. Создайте в ресурсах menu новый menu-файл и опишите там пункт меню. Поставьте ему иконку (share есть в стандартном наборе)
13. В onCreateOptionsMenu фрагмента назначьте созданное в прошлом меню, а в onOptionsItemSelected опишите реакцию на нажатие. 
14. Этой реакцией станет запуск Intent для отправки данных. Он запустит стандартный экран шеринга https://developer.android.com/training/sharing/send
15. Повторите пп. 14-16 из первой практики

### 4. Практика "Комментарий"

В рамках этой практики вам предстоит попробовать паттерн Model View Presenter и библиотеку Moxy, а также внедрение зависимостей и Dagger. Пробовать мы это будем на примере поля ввода. 

1. Для выполнения этой практики вам будут необходимы результаты Практики 3 "Карточка" (может не целиком, главное сам экран). Выполните сначала ее. После вливания "Карточки" встаньте в мастер и стартуйте новую ветку.
2. Возьмите экран из практики "Карточка" и сверстайте на нем простую форму ввода: по нажатию на раздел "Комментарии" будет открывтаться блок с полеем ввода, кнопкой "Отправить" и списком комментариев. 
3. Для поля ввода используйте EditText. Дополнительно - оберните его TextInputLayout для дополнительных возможностей. Экспериментируйте: например, ограничьте количество символов, которые можно ввести. 
4. Сделайте так, чтобы при пустом поле кнопка "Отправить" была недоступна ИЛИ при пустом поле и нажатии кнопки показывалась ошибка. (у EditText/TextInputLayout есть свойство error)
5. Расположите под полем ввода список комментариев, которые будут добавляться по нажатию на кнпоку.  
6. Много логики получается во фрагменте, а состояние не сохраняется. Время применить паттерн MVP. Добавьте библиотеку Moxy:
   
```
def moxyVersion = "2.2.2"
implementation "com.github.moxy-community:moxy:$moxyVersion"
kapt "com.github.moxy-community:moxy-compiler:$moxyVersion"
implementation "com.github.moxy-community:moxy-androidx:$moxyVersion"
implementation "com.github.moxy-community:moxy-ktx:$moxyVersion"
```

Не забудьте добавить плагин kapt и сделайте sync. 
6. Создайте класс CardPresenter (наследник MvpPresenter), интерфейс CardView (Наследник MvpView), а CardFragment сделайте наследником MvpAppCompatFragment и CardMvpView. Так эти компоненты смогут работать в связке. 

7. В CardView вынесите функции вашего экрана, которые будет вызывать презентер и выполянть фрагмент. Это любые действия, меняющие состояние экрана, например показать скрытые виджеты, сделать доступной кнопку, очистить поле ввода.
   
9. В презентере создайте функции, которые вызываются при событии с экрана и требуется принятие решения. Например, юзер нажал на поле "Комментарий", значит, если комменатрии не показаны, их нужно показать, и скрыть, если уже показаны. Показ и скрытие - вызов функции из прошлого пункта.
    
11. Перепишите CardFragment так, чтобы о событиях он докладывал презентеру. Реализуйте все функции из CardView - то, что будет вызываться из презентера.
    
13. В CardView не забудьте указать стратегию Moxy, согласно которой она повторит команды.
    
15. Следующая задача - предоставить фрагменту презентер. Нужно это сделать так, чтобы для воскресшей вьюшки брался тот же презентер, что был изначально. Для этого надо создать "хранилище" зависимостей и управлять им. В этом поможет Dagger. Добавьте нужныые зависимости: 

```
def daggerVersion = "2.50"
    implementation "com.google.dagger:dagger:$daggerVersion"
    kapt "com.google.dagger:dagger-compiler:$daggerVersion"
```

12. Создайте класс App, наследник Application. Он переживет ЖЦ активити. Там будет создан AppComponent - компонент Dagger, управляющий зависимостями.
    
14. В AppComponent поместите следующее:
    
```
@Component
@Singleton
interface AppComponent {

    //Fragments
    fun inject(fragment: CardFragment)

    @Component.Factory
    interface Factory {
        fun create(@BindsInstance context: Context): AppComponent
    }
}
```

14. Чтобы получить презентер в CardFragment, нужно:
    
```
    @Inject
    lateinit var presenterProvider: Provider<CardPresenter>

    private val presenter by moxyPresenter { presenterProvider.get() }

    override fun onCreate(savedInstanceState: Bundle?) {
        App.appComponent?.inject(this)
        super.onCreate(savedInstanceState)
    }
```

Не забудьте пометить конструктор CardPresenter аннотацией Inject. Теперь вы можете пользоваться presenter в вашем фрагменте - его будет создавать компонент. 

15. Проверьте, что, например, при перевороте экрана состояние вашего экрана сохраняется.
    
17. Перепишите в стиле MVP "Статью" и "Список"
  
19. Повторите пп. 14-16 из первой практики

P.S. за подсказками в https://github.com/dekabrsky/MobileDevelopmentCourseLabApp/tree/feature/comment 

### Практика "Сеть" (Чак Норрис)
В этой практике вам предстоит сделать первые сетевые запросы. 

1. Добавьте в Android Manifest нужные разрешения. https://developer.android.com/develop/connectivity/network-ops/connecting
2. Мы будем использовать библиотеки RxJava3 для асинхронности, OkHttp и Retrofit для работы с сетью. Добавьте их в зависимости gradle и сделайте sync. [пример](https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp/blob/feature/network/app/build.gradle)
3. Выберите API, с которым будете работать. На паре мы работали с https://api.chucknorris.io/ - там можно получить случайную шутку про Чака Норриса. Еще могу посоветовать https://api-ninjas.com/api - там есть много различных api. Например, информация о городах (https://api-ninjas.com/api/city), погоде (https://api-ninjas.com/api/weather), машинах, самолетах и так далее. Если вы хотите воспользоваться api-ninjas, нужно будет зарегистрироваться и получить токен.
4. Посмотрите, какой объект отдает выбранный api и создайте соответствующую модель в kotlin. [Пример](https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp/blob/feature/network/app/src/main/kotlin/com/example/mobiledevelopmentcourselabapp/data/model/ChuckJokeResponse.kt)
5. Настройте ваш http-клиент. Лучше всего это сделать во внедряемом Provider. В нем создается OkHttp-клиент (сделайте так, чтобы он логировал запросы, а для api-ninjas добавлял токен в заголовок), который потом передается в Retrofit. Для retrofit указывается базовый url, конвертер (из json в объекты котлина), адаптер для rxjava. [Пример](https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp/blob/feature/network/app/src/main/kotlin/com/example/mobiledevelopmentcourselabapp/data/provider/RetrofitProvider.kt)
6. Создайте интерфейс api, который будет отражением эндпойнтов сервера и того, что и как вы хотите из них получить. Используйте аннотации @GET. [Пример](https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp/blob/feature/network/app/src/main/kotlin/com/example/mobiledevelopmentcourselabapp/data/api/ChuckApi.kt)
7. Определите Dagger-модуль, который свяжет ваш api и provider. Обращение к эндпойнтам будет работать через определенный в провайдере клиент. Не забудьте добавить модуль в компонент. [пример](https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp/blob/feature/network/app/src/main/kotlin/com/example/mobiledevelopmentcourselabapp/di/module/ApiModule.kt)
8. При желании реализуйте чистую архитектуру. Подробнее мы ее разберем позже. [почитать](https://habr.com/ru/companies/otus/articles/732178/)
9. Перепишите ArticleFragment на MVP аналогично практике "Комментарий". Работа с сетью будет вестись в Presenter.
10. Чтобы сделать запрос, добавьте ваш api/repository/useCase в конструктор Presenter (он заинжектится). Вызовите метод, соответствующий нужному запросу. Чтобы запрос выполнился, нужно подписаться на результат выполнения (метод subscribe).
11. Позаботьтесь о том, чтобы запрос ожидался в отдельном потоке, а его результат использовался в основном. [пример](https://github.com/Mobile-Development-Course-LAB-USUE/MobileDevelopmentCourseLabApp/blob/feature/network/app/src/main/kotlin/com/example/mobiledevelopmentcourselabapp/presentation/view/article/presenter/ArticlePresenter.kt)
12. В методе subscribe вызовите метод фрагмента, который поставит информацию в интерфейс. Основная часть практики закончена - результат из сети получен. На тот случай, если результат не получен, сделайте показ ошибки. (onError)
13. Дополнительно - сделайте запрос кастомизируемым. Например, выбрать категорию шутки, набрать город для получения информации о нем и т.д. 
14. Дополнительно - реализуйте визуализацию состояния загрузки. 
15. В отчет включите скриншот логов или network inspector, где виден момент выполенения запроса. Ну и то, что получилось на экране, тоже
16. Повторите пп. 14-16 из первой практики

### Практика "Локальное хранение"
Научитесь сохранять то, что не хотелось бы терять при следующем запуске приложения. 
1. Используя SharedPreferences и/или Data Store, сохраните простые данные с любого экрана. Это может быть счетчик лайков, выбранная категория анекдота или сохраненные данные, полученные из запросов из практики "Сеть" (там может быть несколько подей, сохранить их придется по отдельности). 
2. Научимся создавать список из практики "Список" руками пользователя. Сделаем ему экран, где он будет добавлять объекты в список. 
3. На экране "Список" добавьте меню или кнопку для добавления данных.
4. Создайте экран для добавления данных. Примените EditText, RadioGroup и другие View по вкусу. 
5. Импортиртируйте в проект Room, его компилятор и адаптер для RxJava
6. В соответствии с тем, что вы хотите хранить, создайте класс данных и пометьте его аннотацией Entity
7. Опишите методы работы с БД в классе Dao
8. Опишите вашу БД в классе с аннотацией Database
9. Создавайте экземпляр Database через DI
10. Примените функцию Insert вашего Dao при добавлении нового элемента списка (на экране добавления)
11. Примените функцию Query для получения данных на экране самого списка. Не делать это каждый раз, а только при добавлении нового элемента поможет метод фрагмента setFragmentResult, например
12. К работе приложите запись экрана, на которой данные изменяются, приложение выгружается из памяти, и при следующем запуске состояние остается актуальным
13.Повторите пп. 14-16 из первой практики

### Практика "Фото"
Научитесь сохранять не только простые данные, но и файлы. Например, фото в профилях сотрудников, если у вас список сотрудников, фото товаров и так далее.
1. Воспользуйтесь экраном редактирования из практики "Локальное хранение" - добавьте на форму ImageView, куда пойдет изображение, которое мы будем получать.
2. По нажатию на ImageView должен открываться выбор, откуда получить файл - с камеры или галереи. Предлагается использовать BaseBottomSheetDialog.
3. Ваш bottomsheet-диалог нужно будет добавить в граф навигации с тегом dialog.
4. Возвращайте результат выбора с помощью setResultListener.
5. При нажатии на вариант "Галерея" откройте стандартный пикер изображений. В этом поможет ActivityResultContracts.PickVisualMedia. Обратите внимание, какое открывается приложение или экран. 
6. При нажатии на варинат "Камера" вызовите обработчик ActivityResultContracts.TakePicture. Ему нужен файл, в который сохранится сделанное фото. Расположите его с external files при помощи File Provider.
7. В обоих случаях вы получаете Uri на ресурс. Именно его и сохраните в БД. Для того, чтобы сохранять Uri, можете сделать конвертер. Для того, чтобы добавить новый столбец, необходимо сделать миграцию версии БД.
8. Отображайте картинку по Uri в форме создания, карточке и списке при помощи Glide. Научитесь показывать ее полноэкранно на карточке. 
9. Дополнительно можете поработать с документами и аудиофайлами. 
10. В отчет загрузите скриншоты формы редактирования, списка, картчоки с открытыми изображениями. 
